<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>使用Junit+Mockito方式进行单元测试</title>
    <link href="/2023/10/14/%E4%BD%BF%E7%94%A8Junit-Mockito%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <url>/2023/10/14/%E4%BD%BF%E7%94%A8Junit-Mockito%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一、当前遇到的困难"><a href="#一、当前遇到的困难" class="headerlink" title="一、当前遇到的困难"></a>一、当前遇到的困难</h1><p>在接手业务的代码后，发现当且单测有着这样的一些问题：</p><ul><li>单元测试启动繁琐，开发效率低；需要依赖于Spring服务的启动，耗时太久</li><li>单测覆盖率难以提升；当前Spring启动的方式进行单测，用例无法随心所欲的模拟，往往依赖于自己在测试环境造数据，模拟成本较大。</li><li>依赖于外部数据造成单测流水线的不稳定，当测试环境数据发生变化后，单测会发生失败</li><li>外部同学使用不友好；外部同学使用当前启动服务的方式进行单测编写，由于数据权限管控，本地无法debug调试，单测成本非常高。</li></ul><p>基于以上困难和痛点，我们决定放弃使用Spring的方式去运行单测，而是使用Junit+Mockito的方式进行单测提效。</p><h1 id="二、Why-is-Mockito"><a href="#二、Why-is-Mockito" class="headerlink" title="二、Why is Mockito"></a>二、Why is Mockito</h1><p>为什么要使用 Mock 对象? 使用它有什么好处呢?</p><p>下面我们以一个简单的例子来展示一下 Mock 对象到底有什么用。</p><p>假设我们正在编写一个银行的服务 BankService, 这个服务的依赖关系如下</p><img src="/2023/10/14/%E4%BD%BF%E7%94%A8Junit-Mockito%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/1.jpg" class="" title="服务依赖关系"><p>当我们需要测试 BankService 服务时, 该真么办呢?</p><p>一种方法是构建真实的 BankDao, DB, AccountService 和 AuthService 实例, 然后注入到 BankService 中。</p><p>这是一种既笨重又繁琐的方法, 完全不符合单元测试的精神。（我们的发票单测代码就是这么做的，需要去启动Spring服务然后进行测试） 那么还有一种更加优雅的方法吗? 自然是有的, 那就是我们今天的主角 <strong>Mock Object</strong>. 下面来看一下使用 Mock 对象后的框架图</p><img src="使用Junit-Mockito方式进行单元测试/2.jpg" alt="1" style="zoom: 50%;" /><p>我们看到, BankDao, AccountService 和 AuthService 都使用了虚拟的对象(Mock 对象) 来替换了, 因此我们就可以对 BankService 进行测试, 而不需要关注它的复杂的依赖了。</p><h1 id="三、What-is-Mockito"><a href="#三、What-is-Mockito" class="headerlink" title="三、What is Mockito"></a>三、What is Mockito</h1><p>Mockito 是一个强大的用于 Java 开发的模拟测试框架, 通过 Mockito 我们可以创建和配置 Mock 对象, 进而简化有外部依赖的类的测试。</p><p>使用 Mockito 的大致流程如下:</p><ul><li>创建外部依赖的 Mock 对象, 然后将此 Mock 对象注入到测试类中；</li><li>执行测试代码；</li><li>校验测试代码是否执行正确。</li></ul><h1 id="四、How-to-use-Mockito"><a href="#四、How-to-use-Mockito" class="headerlink" title="四、How to use Mockito"></a>四、How to use Mockito</h1><h2 id="1-使用Mockito的前置依赖"><a href="#1-使用Mockito的前置依赖" class="headerlink" title="1.使用Mockito的前置依赖"></a>1.使用Mockito的前置依赖</h2><p>使用Mockito前，需要进行Mockito库的导入 在Maven项目中，可以在pom.xml文件中添加以下依赖项：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mockito<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mockito-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>附：mockito的maven仓库：<a href="https://mvnrepository.com/artifact/org.mockito/mockito-core">Maven Repository: org.mockito » mockito-core (mvnrepository.com)</a></p><h2 id="2-Mockito的使用方法"><a href="#2-Mockito的使用方法" class="headerlink" title="2.Mockito的使用方法"></a>2.Mockito的使用方法</h2><p>Mockito的主要作用是进行模拟测试，我们通常使用Mockito+junit的方式进行单元测试代码的编写，也可以通过Mockito+spock框架进行单元测试的编写，本文主要介绍Mockito+junit的方式进行单元测试，另外Mockito的玩法是非常多的，下面只是个人使用过程中比较常见的一些场景，感觉目前基本90%的case都可以覆盖解决，类似于打桩顺序等高端玩法基本没用过，后续使用了再分享。</p><h3 id="2-1-Mockito最简单的case举例"><a href="#2-1-Mockito最简单的case举例" class="headerlink" title="2.1 Mockito最简单的case举例"></a>2.1 Mockito最简单的case举例</h3><p>当前有一个类需要进行单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Target</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;default&quot;</span>;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">someMethod</span><span class="hljs-params">(String arg)</span> &#123;<br>    <span class="hljs-keyword">return</span> arg + <span class="hljs-string">&quot;!!!&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;static&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> Integer <span class="hljs-title function_">getIdByName</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(name)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;&#123;&quot;</span>);<br>    sb.append(<span class="hljs-string">&quot;\&quot;name\&quot;:\&quot;&quot;</span>);<br>    sb.append(name).append(<span class="hljs-string">&#x27;\&quot;&#x27;</span>);<br>    sb.append(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>    <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法中没有任何其他对象依赖使用了，那么可以使用如下方式进行单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMockito</span> &#123;<br>    <span class="hljs-meta">@Mock</span><br>    <span class="hljs-keyword">private</span> Target target;<br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> &#123;<br>        MockitoAnnotations.initMocks(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 使用注解方式需要初始化或者在类上加上注解@RunWith(MockitoJUnitRunner.class)</span><br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testxxx</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>@Mock 注解可以看做一个语法糖，用更少的代码实现相同的 mock 功能，上述@mock的内容可以完全等价于Target target &#x3D; Mockito.mock(Target.class)，特别是在许多测试方法中都要用到这样一个 mock 对象的时候。</li><li>@before中的MockitoAnnotations.initMocks(this)等价于在类的上方使用注解@RunWith(MockitoJunitRunner.class)，其作用就是对该 mock 对象进行初始化，如果不进行操作，单测会抛出NPE异常</li></ul><h3 id="2-2-当对象内存在依赖对象时进行单元测试"><a href="#2-2-当对象内存在依赖对象时进行单元测试" class="headerlink" title="2.2 当对象内存在依赖对象时进行单元测试"></a>2.2 当对象内存在依赖对象时进行单元测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(MockitoJunitRunner.class)</span> <span class="hljs-comment">// 或使用上述initMocks的方式。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMockito</span> &#123;<br><span class="hljs-meta">@InjectMocks</span><br><span class="hljs-keyword">private</span> XXService xxService;<br><span class="hljs-meta">@Mock</span><br><span class="hljs-keyword">private</span> A a;<br><span class="hljs-meta">@Mock</span><br><span class="hljs-keyword">private</span> B b;<br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testxxx</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>@InjectMocks将@Mock注解的对象注入到XXService对象中</p><h3 id="2-3-针对抽象接口的单元测试"><a href="#2-3-针对抽象接口的单元测试" class="headerlink" title="2.3 针对抽象接口的单元测试"></a>2.3 针对抽象接口的单元测试</h3><img src="使用Junit-Mockito方式进行单元测试/3.jpg" alt="1" style="zoom:50%;" /><p>针对service.method()方法，由于service为抽象接口，通过@mock的方式会出现NPE问题，此时通过如下方式进行初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 业务服务相关单元测试</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> nmerkbw</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2023-08-29-9:39 AM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">eControllerTest</span> &#123;<br><br>    <span class="hljs-meta">@InjectMocks</span><br>    <span class="hljs-keyword">private</span> Controller controller;<br><br>    <span class="hljs-keyword">private</span> IService1 service1;<br>    <span class="hljs-keyword">private</span> IServiCe2 serviCe2;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setup</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        MockitoAnnotations.initMocks(<span class="hljs-built_in">this</span>);<br>        service1 = Mockito.mock(IService.class);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field1</span> <span class="hljs-operator">=</span> controller.getClass().getDeclaredField(<span class="hljs-string">&quot;service1&quot;</span>);<br>        field1.setAccessible(<span class="hljs-literal">true</span>);<br>        field1.set(controller, service1);<br><br>        serviCe2 = Mockito.mock(IServiCe2.class);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field2</span> <span class="hljs-operator">=</span> controller.getClass().getDeclaredField(<span class="hljs-string">&quot;serviCe2&quot;</span>);<br>        field2.setAccessible(<span class="hljs-literal">true</span>);<br>        field2.set(controller, serviCe2);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// build</span><br>        <span class="hljs-type">BaseAccount</span> <span class="hljs-variable">account</span> <span class="hljs-operator">=</span> Mockito.mock(BaseAccount.class);<br>        account.setAccountId(<span class="hljs-string">&quot;2313123&quot;</span>);<br>        account.setBizCustomerId(<span class="hljs-string">&quot;3235554&quot;</span>);<br><br>        <span class="hljs-type">CreateInvoiceServiceRedeemCodeOrderRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CreateInvoiceServiceRedeemCodeOrderRequest</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;3213214432545&quot;</span>;<br>        <span class="hljs-type">Request</span> <span class="hljs-variable">requeSt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>();<br>        request.setShopName(<span class="hljs-string">&quot;test&quot;</span>);<br>        request.setShopNum(<span class="hljs-string">&quot;1234567&quot;</span>);<br>        request.setCustomerId(<span class="hljs-string">&quot;7654321&quot;</span>);<br>        request.setOrderChooseShopList(Lists.newArrayList(request));<br>        request.setRedeemer(<span class="hljs-string">&quot;nmerkbw&quot;</span>);<br>        request.setRedeemCode(code);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">viewId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1696063630858022991&quot;</span>;<br>        <span class="hljs-type">ResultVo</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResultVo</span>();<br>        order.setViewId(viewId);<br><br>        <span class="hljs-type">CommonResponse</span> <span class="hljs-variable">commonResponse</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonResponse</span>();<br>        commonResponse.setCode(RedemptionResponseCodeEnum.FAILED.getCode());<br><br>        <span class="hljs-comment">// mock</span><br>        Mockito.when(serviCe2.createOrder(Mockito.any(), Mockito.any())).thenReturn(order);<br>        Mockito.when(service1.modifyRedeemStatus(Mockito.any(), Mockito.any(), Mockito.anyString())).thenReturn(commonResponse);<br><br>        WebResponse&lt;String&gt; response = controller.saveOrderChooseShopForRedemption(account, request);<br>        Assert.assertEquals(ResponseEnum.PARAMETER_ILLEGAL.getCode(), response.getCode());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-针对静态方法的模拟测试"><a href="#2-4-针对静态方法的模拟测试" class="headerlink" title="2.4 针对静态方法的模拟测试"></a>2.4 针对静态方法的模拟测试</h3><h4 id="Mockito-（推荐）"><a href="#Mockito-（推荐）" class="headerlink" title="Mockito （推荐）"></a>Mockito （推荐）</h4><p>mockito针对静态方法的模拟需要依赖包mockito-inline，从Mockito 3.4.0开始，可以使用Mockito.mockStatic（Class <T> classToMock）方法来模拟对静态方法调用的调用。此方法为我们的类型返回一个MockedStatic对象，这是一个有范围的模拟对象。</p><p>为了把这种方式介绍的更为详尽，我们开启一个全新的篇幅来介绍这种模拟方式，请跳转：<a href="https://km.sankuai.com/collabpage/1898979768">使用Mockito进行静态方法模拟</a></p><p>这种方式不仅能模拟静态方法，还能解决与一些覆盖率平台之间不兼容的情况。</p><h4 id="PowerMock（过时）"><a href="#PowerMock（过时）" class="headerlink" title="PowerMock（过时）"></a>PowerMock（过时）</h4><p>针对静态方法，需要引入PowerMock来进行模拟和测试。PowerMock是在Mockito原有的基础上做了扩展，通过修改类字节码并使用自定义ClassLoader加载运行的方式来实现mock静态方法、final方法、private方法、系统类的功能。 从两者的项目结构中就可以看出，PowerMock直接依赖于Mockito，所以如果项目中已经导入了PowerMock包就不需要再单独导入Mockito包，如果两者同时导入还要小心PowerMock和Mockito不同版本之间的兼容问题，另外PowerMock没有再维护了，不再推荐使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(PowerMockRunner.class)</span><br><span class="hljs-meta">@PrepareForTest(&#123;YodaConfigService.class, ContainerHelper.class&#125;)</span> <span class="hljs-comment">// 需要模拟的静态类</span><br><span class="hljs-meta">@PowerMockIgnore(&quot;javax.management.*&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ContainerHelperTest</span> &#123;<br><br>    <span class="hljs-meta">@InjectMocks</span><br>    <span class="hljs-keyword">private</span> ContainerHelper containerHelper;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;<br>        MockitoAnnotations.initMocks(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testIsSupportAction</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1.对类进行mock</span><br>        PowerMockito.mockStatic(YodaConfigService.class);<br>        <span class="hljs-comment">// 2.对方法进行打桩后即可</span><br>        PowerMockito.when(YodaConfigService.getContainerH5RisklevelSwitchMap()).thenReturn(containerH5RisklevelSwitchMap);<br><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> containerHelper.getClass().getDeclaredMethod(<span class="hljs-string">&quot;isSupportAction&quot;</span>, String.class);<br>        method.setAccessible(<span class="hljs-literal">true</span>);<br>        Assert.assertTrue((Boolean) method.invoke(containerHelper, action));<br>        Assert.assertFalse((Boolean) method.invoke(containerHelper, notSupportAction));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>问题：PowerMock引入后，与有些覆盖率统计存在不兼容的问题，导致PowerMock模拟的单元测试无法进行覆盖</strong></p><h3 id="2-5-针对私有方法的模拟测试"><a href="#2-5-针对私有方法的模拟测试" class="headerlink" title="2.5 针对私有方法的模拟测试"></a>2.5 针对私有方法的模拟测试</h3><p>以2.1的Target.getIdByName(String name)这个私有方法为例，一般通过反射的方式调用到私有方法进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TargetTest</span> &#123;<br><br>    <span class="hljs-meta">@Mock</span><br>    <span class="hljs-keyword">private</span> Target target;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;<br>        MockitoAnnotations.initMocks(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> Target.class.getDeclaredMethod(<span class="hljs-string">&quot;getIdByName&quot;</span>, String.class);<br>        method.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;nmerkbw&quot;</span>;<br>        Assert.assertEquals(<span class="hljs-number">2</span>, Integer.valueOf(method.invoke(target, name).toString()).intValue());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-6-针对SpringBootTest服务进行Mock"><a href="#2-6-针对SpringBootTest服务进行Mock" class="headerlink" title="2.6 针对SpringBootTest服务进行Mock"></a>2.6 针对SpringBootTest服务进行Mock</h3><p>通常对需要mock的对象使用@MockBean的方式进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserResourceTests</span> &#123;<br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> MockMvc mockMvc;<br><br>  <span class="hljs-meta">@MockBean</span><br>  <span class="hljs-keyword">private</span> UserRepository userRepository;<br><br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;username\&quot;:\&quot;shekhargulati\&quot;,\&quot;name\&quot;:\&quot;Shekhar Gulati\&quot;&#125;&quot;</span><br>    when(userRepository.save(Mockito.any(User::class.java))).thenReturn(User(<span class="hljs-string">&quot;123&quot;</span>))<br>    mockMvc.dosomething();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-7-Mock常用方式"><a href="#2-7-Mock常用方式" class="headerlink" title="2.7 Mock常用方式"></a>2.7 Mock常用方式</h3><p>Mockito.when(…).thenReturn(…) 触发接口时返回固定值</p><p>Mockito.when(…).then(…) 触发接口时自定义接口返回，需要实现接口，下同</p><p>Mockito.when(…).thenAnswer(…)</p><p>Mockito.when(…).thenThrow(…) 触发接口时抛出异常</p><p>Mockito.doNothing.when(…).method() 针对void方法</p><p>when(…).thenCallRealMethod() 触发接口时调用真实方法，针对的是spy模拟的对象</p><p>Mockito.spy() 模拟，可以控制执行前和执行后</p><p>Mockito.verify() 可实现一些校验，例如方法是否执行、执行了几次、方法执行的顺序等</p><h3 id="2-8-常见问题"><a href="#2-8-常见问题" class="headerlink" title="2.8 常见问题"></a>2.8 常见问题</h3><p><strong>when(…).thenReturn(…)和doReturn(…).when(…）的区别</strong></p><p>在Mockito中打桩（即stub)有两种方法when(…).thenReturn(…)和doReturn(…).when(…)。这两个方法在大部分情况下都是可以相互替换的，但是在使用了Spies对象（@Spy注解），而不是mock对象（@Mock注解)的情况下他们调用的结果是不相同的（目前我只知道这一种情况，可能还有别的情形下是不能相互替换的）</p><p><strong>Spy和mock的区别</strong></p><p>Spy我这边用的比较少，和mock的区别核心就在于是否调用了真实的方法，具体区别如下：</p><table><thead><tr><th>场景</th><th>Spy</th><th>Mock</th></tr></thead><tbody><tr><td>普通类</td><td>调用真实的方法</td><td>根据调用方法返回值类型直接返回默认值</td></tr><tr><td>抽象类</td><td>对于非抽象方法，调用真实的方法；对于抽象方法，根据调用方法返回值类型直接返回默认值</td><td>任何类型的方法都是根据调用方法返回值类型直接返回默认值</td></tr><tr><td>接口</td><td>根据调用方法返回值类型直接返回默认值</td><td>根据调用方法返回值类型直接返回默认值</td></tr></tbody></table><p><strong>Mock和MockBean的区别</strong></p><p>Spring Boot 中@Mock 和@MockBean 注解的区别 <strong>@Mock用于模拟不属于Spring 上下文的对象，而@MockBean 用于模拟属于一部分的对象Spring上下文的</strong>。 它用于带有Mockito 框架的普通JUnit 测试。</p><h2 id="3-引申-使用Mockito-spock框架进行单元测试"><a href="#3-引申-使用Mockito-spock框架进行单元测试" class="headerlink" title="3.引申-使用Mockito+spock框架进行单元测试"></a>3.引申-使用Mockito+spock框架进行单元测试</h2><p>Spock是一款国外优秀的测试框架，基于BDD（行为驱动开发）思想实现，功能非常强大。Spock结合Groovy动态语言的特点，提供了各种标签，并采用简单、通用、结构化的描述语言，让编写测试代码更加简洁、高效。</p><p>如果在（if&#x2F;else）分支很多的复杂场景下，编写单元测试代码的成本会变得非常高，正常的业务代码可能只有几十行，但为了测试这个功能覆盖大部分的分支场景，编写的测试代码可能远不止几十行。</p><p>尽管使用JUnit的@Parametered参数化注解或者DataProvider方式可以解决多数据分支问题，但不够直观，而且如果其中某一次分支测试Case出错了，它的报错信息也不够详尽。</p><p>这就需要一种编写测试用例高效、可读性强、占用工时少、维护成本低的测试框架。首先不能让业务人员排斥编写单元测试，更不能让工程师觉得写单元测试是在浪费时间。而且使用JUnit做测试工作量不算小。据初步统计，采用JUnit的话，它的测试代码行和业务代码行能到3:1。如果采用Spock作为测试框架的话，它的比例可缩减到1:1，能够大大提高编写测试用例的效率。</p><h3 id="五-Mock相关的原理"><a href="#五-Mock相关的原理" class="headerlink" title="# 五 Mock相关的原理"></a># 五 Mock相关的原理</h3><p>Mock本质上是一个Proxy代理模式的应用。</p><p>Proxy模式，是在对象提供一个proxy对象，所有对真实对象的调用，都先经过proxy对象，然后由proxy对象根据情况，决定相应的处理，它可以直接做一个自己的处理，也可以再调用真实对象对应的方法。</p><p>所以Mockito本质上就是在代理对象调用方法前，用stub的方式设置其返回值，然后在真实调用时，用代理对象返回起预设的返回值。</p><p>附：原理参考</p><p><a href="https://juejin.cn/post/7034528267721768990">深入Java单元测试mock技术Mockito的原理 - 掘金 (juejin.cn)</a></p><p><a href="https://zhuanlan.zhihu.com/p/87523954">mockito原理浅析 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/28983008">Mockito的使用及原理及分析 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>单元测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo文章创建与推送</title>
    <link href="/2023/08/05/hexo%E6%96%87%E7%AB%A0%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%8E%A8%E9%80%81/"/>
    <url>/2023/08/05/hexo%E6%96%87%E7%AB%A0%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%8E%A8%E9%80%81/</url>
    
    <content type="html"><![CDATA[<h2 id="文章创建与推送"><a href="#文章创建与推送" class="headerlink" title="文章创建与推送"></a>文章创建与推送</h2><h3 id="1-创建文章"><a href="#1-创建文章" class="headerlink" title="1.创建文章"></a>1.创建文章</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">post</span> 文章名称<br></code></pre></td></tr></table></figure><h3 id="2-推送文章"><a href="#2-推送文章" class="headerlink" title="2.推送文章"></a>2.推送文章</h3><p>目前将根目录下的_config.yml做了相关配置，绑定到了自己的github上，通过hexo的命令来进行推送的</p><p>安装hexo-deployer-git</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>修改根目录下的_config.yml，配置github相关信息</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> 仓库地址<br><span class="hljs-symbol">  branch:</span> main<br><span class="hljs-symbol">  token:</span> 从GitHub中获取<br></code></pre></td></tr></table></figure><p>部署到github</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g -d</span><br></code></pre></td></tr></table></figure><h3 id="3-本地启动"><a href="#3-本地启动" class="headerlink" title="3.本地启动"></a>3.本地启动</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g -d</span><br><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure><h3 id="4-关于更新"><a href="#4-关于更新" class="headerlink" title="4.关于更新"></a>4.关于更新</h3><p>关注github上release包：<a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">Releases · fluid-dev&#x2F;hexo-theme-fluid (github.com)</a></p><hr><p>关于fluid的详细配置和参考：</p><p><a href="https://blog.csdn.net/yaorongke/article/details/119089190">GitHub Pages + Hexo搭建个人博客网站，史上最全教程_hexo博客_淡淡的说非的博客-CSDN博客</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo_fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/07/15/hello-world/"/>
    <url>/2023/07/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
